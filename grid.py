from shipSpeed import shipSpeed
import math
import time

def calculate_distance(x1, y1, x2, y2):
    # Euclidean Formula
    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

def generate_grid_points(start_lat, start_lon, end_lat, end_lon, step_deg):
    """
   Generates the intermediate points which are geographical coordinates (latitude and longitude)
   between the start and end position on the map with a given step size in degrees. 
   For example, if the step size is 0.08 degrees, then the grid will have a size 
   of 0.08 degrees. 4 adjacent points make one grid.

   8,10--8,11--8,12
    |   1  |  2   |
    |      |      |
   9,10--9,11--9,12

   Here the points are what is generated by this function

    Parameters:
        start_lat: The starting latitude.
        start_lon: The starting longitude.
         end_lat: The ending latitude.
        end_lon: The ending longitude.
        step_deg: The step size in degrees for latitude and longitude.
    Returns:
        list: A 2D list (grid) containing tuples of (latitude, longitude).
    """
    grid = []

    # Adjust step direction based on start and end latitudes
    if start_lat > end_lat:
        lat_step = -step_deg
    else:
        lat_step = step_deg

    # Adjust step direction based on start and end longitudes
    if start_lon > end_lon:
        lon_step = -step_deg
    else:
        lon_step = step_deg

    # Iterate over latitude from start to end with given step
    lat = start_lat
    while (lat_step > 0 and lat <= end_lat) or (lat_step < 0 and lat >= end_lat):
        row = []
        lon = start_lon
        while (lon_step > 0 and lon <= end_lon) or (lon_step < 0 and lon >= end_lon):
            row.append((round(lat, 2), round(lon, 2)))
            lon += lon_step
        grid.append(row)
        lat += lat_step

    return grid

def calculate_orientation_and_distance(points_grid, path, step_size):
    '''
    Calculates the orientation of the ship with respect to north in each grid, that is the bearing angle.
    Representation of the 4 direction in degree
        0 degrees: North
        90 degrees: East
        180 degrees: South
        270 degrees: West
    Calculates the distance of the ship in each of the grid
    Returns:
       A grid where for each grid cell that the ship passes through, we record the orientation of the ship within that cell and the distance 
       it travels between two points, relative to the north direction, as (orientation, distance). If the ship does not travel 
       through a grid cell, it is represented as -1.
    Parameter:
        points_grid -> The input grid containing latitude and longitude points.
        path -> The path of the ship as a list of (latitude, longitude). 
        step_deg -> The step size in degrees for latitude and longitude.
    '''
    # Stores our result
    rows = len(points_grid)
    cols = len(points_grid[0])
    # Create a grid with all values initialized to -1
    orientation_distance_grid = [-1] * (rows * cols)

    # If this is my path 80,1 -> 91,3 -> 103,4 -> 102,7
    # We iterate between each pair of successive points (80,1 -> 91,3), (91,3 -> 103,4), (103,4 -> 102,7)
    for i in range(len(path) - 1):
        lat1, lon1 = path[i]
        lat2, lon2 = path[i+1]

        # https://en.wikipedia.org/wiki/Atan2 can be used to find the angle measure (in radians, between the positive x-axis 
        # and the ray from the origin to the point (x,y). https://www.movable-type.co.uk/scripts/latlong.html formula taken 
        # from here

        y = math.sin(lon1 - lon2) * math.cos(lat2)
        x = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(lon1 - lon2)
        thetha = math.atan2(y, x) # In radian
        brng = (thetha * 180 / math.pi + 360) % 360 # In degree

        # Find all the grids which intercept the path between start and end lat lon
        grids , distances = get_intercepting_grid_with_distance(lat1,lon1,lat2,lon2,points_grid[0][0][0],points_grid[0][0][1],step_size,len(points_grid),len(points_grid[0]))
        
        # Populate the orientation grid with the orientation and distance for each grid the ship passes through
        count = 0
        for grid in grids:
            orientation_distance_grid[grid-1] = (brng,distances[count])
            count += 1

        return orientation_distance_grid

def get_grid_identifier(x, y, grid_point_rows,grid_point_cols):
    """
    Calculate the grid identifier based on coordinates (x, y).
    Given a point on the top right corner of a grid, we return the grid index
    (0,0) (0,1) 
         1    
    (1,0) (1,1)
    For the above grid, if we input top index (0,1) we get the grid index 1
    """
    # Top Right in cartesian, bottom right in our grid
    grid_index = ((grid_point_rows - 1) * (y - 1)) + x
    return grid_index

def get_intercepting_grid_with_distance(lat1,lon1,lat2,lon2,start_lat1,start_lon1,step,grid_point_rows,grid_point_cols):
    '''
    Finds all the grids which touches the path of the ship and the travel distance of the ship in that grid
    Returns:
        A list of indexes (row, column) in the grid where the ship's path intersects and a list of distances of those grids.
    Parameters:
        lat1: The starting latitude of the path.
        lat2: The ending latitude of the path.
        lon1: The starting longitude of the path.
        lon2: The ending longitude of the path.
        start_lat1: The starting latitude of the grid.
        start_lon2: The starting longitude of the grid.
        step: The size of each grid.
        grid_point_rows: Number of points in the grid row
        grid_point_cols: Number of points in the grid col
    '''
    
    # Below is our grid looks like, which is normalized to integers from lat,lon based on the step, the values
    # in between the points is the grid number
    # (0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (0,6)
    #      1     3     5     7     9     11
    # (1,0) (1,1) (1,2) (1,3) (1,4) (1,5) (1,6)
    #      2     4     6     8    10     12 
    # (2,0) (2,1) (2,2) (2,3) (2,4) (2,5) (2,6)
    # When we consider a map, the latitude is the X axis and the longitude is the Y axis
    # Since we are using cartesian coordinates we flip the notation, therefore Y as horizontal and X as vertical
    # therfore during iteration we consider the grid index from top to bottom, left to right

    x0 = int((lon1 - start_lon1) / step)
    y0 = int((start_lat1 - lat1) / step)
    x1 = int((lat2 - start_lat1) / step)
    y1 = int((lon2 - start_lon1) / step)

    # Line is closer to the horizontal axis 
    if abs(y1 - y0) < abs(x1 - x0):
        if x0 > x1:
            # Slanting from right to left 
            grids , distances= helper_line_low(x1, y1, x0, y0, grid_point_rows, grid_point_cols)
        else:
            # Slanting from left to right 
            grids , distances= helper_line_low(x0, y0, x1, y1, grid_point_rows, grid_point_cols)
    # Line is closer to the vertical axis 
    else:
        if y0 > y1:
            # Slanting from right to left
            grids , distances= helper_line_high(x1, y1, x0, y0, grid_point_rows, grid_point_cols)
        else:
            # Slanting from left to right
            grids , distances= helper_line_high(x0, y0, x1, y1, grid_point_rows, grid_point_cols)

    return grids , distances

def helper_line_low(x0, y0, x1, y1, grid_point_rows, grid_point_cols):
    grids = []
    distances = []
    # Calculate the slope (m)
    m = (y1 - y0) / (x1 - x0)

    # xi stores how we want to traverse in the for loop, forward or backward
    xi = 1 # If 1 we go up
    if(m < 0):
        xi = -1 # If -1 we go down

    offset = 0
    # If we reversing, we get the top left point therefore we use this offset to add 1 to x if we are
    if(m < 0):
        offset = 1

    # Calculate the y-intercept (c)
    c = y0 - m * x0

    # Tracks the previous point
    prev_x, prev_y = x0, y0 

    # There will be the case where a line passes through 2 grids at once, to identify such we need to iterate though y and see
    # if the line passes though this and the x is a float, if it is a float it means the line cuts in the middle. To avoid 
    # unneccesary iteration we can just check y, whenever it crosses some integer value
    for x in range(x0+xi,x1+xi,xi):
        # Calculate y for the given x
        y = m * x + c
        # Check if the line cuts two grids at the same time, calculate for both grids if it does
        # int(y) != y is for seeing if the line is going through values like (2,3) (1,1) where y is integer in such case we can ignore, since it is passing through a integer point
        # rather than a float point which is what cuts through 2 grids
        if( int(prev_y) < int(y) and x != x1 and int(y) != y): # Suppose previous y is 2.9 and current y is 3.1 then there is an intersection between
            # suppose y = 2.2 and x intersection is 8.5
            y_floor = math.floor(y) # Stores the floor of y = 2, we use this to find the bottom grid
            x_inter = (y_floor - c)/ m # Stores the intersection = 8.5
            # Gets the first grid, top right point will be current x = 9 and y = 2
            grids.append(get_grid_identifier(x + offset,y_floor,grid_point_rows,grid_point_cols))  
            distances.append(calculate_distance(prev_x, prev_y, x_inter, y_floor)) 
            # Gets the second grid, top right point will be current x = 9 and y = 3
            grids.append(get_grid_identifier(x + offset,math.ceil(y),grid_point_rows,grid_point_cols)) 
            distances.append(calculate_distance(x_inter, y_floor, x, y)) 
        # Calculate for one grid
        else:
            grids.append(get_grid_identifier(x + offset,math.ceil(y),grid_point_rows,grid_point_cols)) 
            distances.append(calculate_distance(prev_x, prev_y, x, y)) 
        prev_x = x
        prev_y = y

    return grids , distances  

def helper_line_high(x0, y0, x1, y1, grid_point_rows, grid_point_cols):
    grids = []
    distances = []
    # Calculate the slope (m)
    m = (y1 - y0) / (x1 - x0)

    # yi stores how we want to traverse in the for loop, forward or backward
    yi = 1 # If 1 we go up
    if(m < 0):
        yi = -1 # If -1 we go down

    offset = 1
    # If we reversing, we get the bottom right point therefore we use this offset to add 1 to y if we are
    if(m < 0):
        offset = 0

    # Calculate the y-intercept (c)
    c = y0 - m * x0

    # Tracks the previous point to calculate the distance
    prev_x, prev_y = x0, y0 

   # Iterate over y from y0 to y1 (going downwards)
    for y in range(y0, y1, yi):
        # Calculate x for the given y
        x = (y - c) / m

        # Check if the line cuts two grids at the same time
        if (int(prev_x) < int(x) and int(x) != x):
            # suppose x = 1.2 and y intersection is 3.5
            x_floor = math.floor(x) # Stores the floor of x = 1
            y_inter = m * x_floor + c # Stores the intersection = 3.5
            # Gets the first grid, top right point will be current x = 1 and y = 4
            grids.append(get_grid_identifier(x_floor + 1, y, grid_point_rows, grid_point_cols))
            distances.append(calculate_distance(prev_x, prev_y, x_floor, y_inter)) 
            # Gets the second grid, top right point will be current x = 2 and y = 4
            grids.append(get_grid_identifier(x_floor + 1, y + 1, grid_point_rows, grid_point_cols)) 
            distances.append(calculate_distance(x_floor, y_inter, x, y)) 
        else:
            grids.append(get_grid_identifier(math.floor(x) + 1, y + offset, grid_point_rows, grid_point_cols))
            distances.append(calculate_distance(prev_x, prev_y, x, y))
        prev_x = x
        prev_y = y

    return grids, distances

def main():
    # Generate grid with 0.08 degree step
    grid = generate_grid_points(2,2,8,4,1)
    # for row in grid:
    #     for pos in row:
    #         print(pos)

    start_time = time.time()
    
    # # Print the points
    # print("Points the line passes through:")s
    # for g in grid:
    #     print(g)

    # calculate_orientation(grid,[(9.6, 78.8),(9.1, 80.2)],0.08)

    # print(helper_line_low(10,0,0,4,11,5))
    # print(helper_line_low(0,0,10,4,11,5))
    print(helper_line_high(0,0,3,10,4,11))
    print(helper_line_high(0,6,2,1,3,7))

    #ship speed calculation
    #def __init__(self, ship_speed, wave_height, displacement, k1, k2, k3, k4, wind_speed, angle):
    # ship = shipSpeed( 30, 1.26, 200000,  1.08, 0.126, 2.77, 2.33, 15, 30)
    # speed = ship.getSpeed()
    # print(speed)
        
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"Time taken to execute: {elapsed_time:.8f} seconds")


if __name__ == "__main__":
    main()

