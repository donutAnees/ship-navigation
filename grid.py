from shipSpeed import shipSpeed
import math
import time

def calculate_distance(x1, y1, x2, y2):
    # Euclidean Formula
    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

def generate_grid_points(start_lat, end_lat, start_lon, end_lon, step_deg):
    """
   Generates points which are geographical coordinates (latitude and longitude), 
   based on the specified start and end points with a given step size in degrees. 
   For example, if the step size is 0.08 degrees, then the grid will have a size 
   of 0.08 degrees. 4 adjancent points make one grid.

   8,10--8,11--8,12
    |   1  |  2   |
    |      |      |
   9,10--9,11--9,12

   Here the points are what is generated by this function

    Parameters:
        start_lat: The starting latitude.
        end_lat: The ending latitude.
        start_lon: The starting longitude.
        end_lon: The ending longitude.
        step_deg: The step size in degrees for latitude and longitude.
    Returns:
        list: A 2D list (grid) containing tuples of (latitude, longitude).
    """
    grid = []

    # Adjust step direction based on start and end latitudes
    if start_lat > end_lat:
        lat_step = -step_deg
    else:
        lat_step = step_deg

    # Adjust step direction based on start and end longitudes
    if start_lon > end_lon:
        lon_step = -step_deg
    else:
        lon_step = step_deg

    # Iterate over latitude from start to end with given step
    lat = start_lat
    while (lat_step > 0 and lat <= end_lat) or (lat_step < 0 and lat >= end_lat):
        row = []
        lon = start_lon
        while (lon_step > 0 and lon <= end_lon) or (lon_step < 0 and lon >= end_lon):
            row.append((round(lat, 2), round(lon, 2)))
            lon += lon_step
        grid.append(row)
        lat += lat_step

    return grid

def calculate_orientation(grid, path, step_size):
    '''
    Calculates the orientation of the ship with respect to north in each grid, that is the bearing angle.
    Representation of the 4 direction in degree
        0 degrees: North
        90 degrees: East
        180 degrees: South
        270 degrees: West
    Returns:
        A grid which contains the orientation of the ship, if the ship doesn't travel through that grid, then it is represented as -1
    Parameter:
        grid -> The input grid containing latitude and longitude points.
        path -> The path of the ship as a list of (latitude, longitude). 
        step_deg -> The step size in degrees for latitude and longitude.
    '''
    for i in range(len(path) - 1):
        lat1, lon1 = path[i]
        lat2, lon2 = path[i+1]

        # https://en.wikipedia.org/wiki/Atan2 can be used to find the angle measure (in radians, between the positive x-axis 
        # and the ray from the origin to the point (x,y). https://www.movable-type.co.uk/scripts/latlong.html formula taken 
        # from here

        y = math.sin(lon1 - lon2) * math.cos(lat2)
        x = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(lon1 - lon2)
        thetha = math.atan2(y, x) # In radian
        brng = (thetha * 180 / math.pi + 360) % 360 # In degree

        # Find all the grids which intercept the path between start and end lat lon
        grids = get_intercepting_grid(lat1,lon1,lat2,lon2,grid[0][0][0],grid[0][0][1],step_size,len(grid),len(grid[0]))
        for g in grids:
            print(g)  

def get_grid_identifier(x, y, grid_point_rows,grid_point_cols):
    """
    Calculate the grid identifier based on coordinates (x, y).
    Given a point on the top right corner of a grid, we return the grid index
    """
    # Top Right in cartesian, bottom right in our grid
    grid_index = ((grid_point_rows - 1) * (y - 1)) + x
    return grid_index

def get_intercepting_grid(lat1,lon1,lat2,lon2,start_lat1,start_lon1,step,grid_point_rows,grid_point_cols):
    '''
    Finds all the grids which touches the path of the ship
    Returns:
        A list of indexes (row, column) in the grid where the ship's path intersects.
    Parameters:
        lat1: The starting latitude of the path.
        lat2: The ending latitude of the path.
        lon1: The starting longitude of the path.
        lon2: The ending longitude of the path.
        start_lat1: The starting latitude of the grid.
        start_lon2: The starting longitude of the grid.
        step: The size of each grid.
        grid_point_rows: Number of points in the grid row
        grid_point_cols: Number of points in the grid col
    '''

    # Below is our grid looks like, which is normalized to integers from lat,lon based on the step, the values
    # in between the points is the grid number
    # (0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (0,6)
    #      1     3     5     7     9     11
    # (1,0) (1,1) (1,2) (1,3) (1,4) (1,5) (1,6)
    #      2     4     6     8    10     12 
    # (2,0) (2,1) (2,2) (2,3) (2,4) (2,5) (2,6)
    # Since we are using cartesian coordinates, hence we consider the grid index from top to bottom, left to right

    x0 = int((lon1 - start_lon1) / step)
    y0 = int((start_lat1 - lat1) / step)
    x1 = int((lon2 - start_lon1) / step)
    y1 = int((start_lat1 - lat2) / step)

    if abs(y1 - y0) < abs(x1 - x0):
        if x0 > x1:
            # Slanting from right to left
            grids = helper_line_low(x1, y1, x0, y0, grid_point_rows, grid_point_cols)
        else:
            # Slanting from left to right
            grids = helper_line_low(x0, y0, x1, y1, grid_point_rows, grid_point_cols)
    else:
        if y0 > y1:
            # Slanting from right to left
            grids = helper_line_high(x1, y1, x0, y0, grid_point_rows, grid_point_cols)
        else:
            # Slanting from left to right
            grids = helper_line_high(x0, y0, x1, y1, grid_point_rows, grid_point_cols)

    return grids

def helper_line_low(x0, y0, x1, y1, grid_point_rows, grid_point_cols):
    grids = []
    distances = []
    # Calculate the slope (m)
    m = (y1 - y0) / (x1 - x0)
    
    # Calculate the y-intercept (c)
    c = y0 - m * x0

    # Tracks the previous point
    prev_x, prev_y = x0, y0 

    # There will be the case where a line passes through 2 grids at once, to identify such we need to iterate though y and see
    # if the line passes though this and the x is a float, if it is a float it means the line cuts in the middle. To avoid 
    # unneccesary iteration we can just check y, whenever it crosses some integer value
    for x in range(x0+1,x1+1):
        # Calculate y for the given x
        y = m * x + c
        # Check if the line cuts two grids at the same time, calculate for both grids
        if( int(prev_y) < int(y) and x != x1):
            y_floor = math.floor(y)
            x_inter = (y_floor - c)/ m
            grids.append(get_grid_identifier(x,y_floor,grid_point_rows,grid_point_cols))  
            distances.append(calculate_distance(prev_x, prev_y, x_inter, y_floor)) 
            grids.append(get_grid_identifier(x,math.ceil(y),grid_point_rows,grid_point_cols)) 
            distances.append(calculate_distance(x_inter, y_floor, x, y)) 
        # Calculate for one grid
        else:
            grids.append(get_grid_identifier(x,math.ceil(y),grid_point_rows,grid_point_cols)) 
            distances.append(calculate_distance(prev_x, prev_y, x, y)) 
        prev_x = x
        prev_y = y

    return grids , distances

def helper_line_high(x0, y0, x1, y1, grid_point_rows, grid_point_cols):
    grids = []
    distances = []
    # Calculate the slope (m)
    m = (y1 - y0) / (x1 - x0)
    
    # Calculate the y-intercept (c)
    c = y0 - m * x0

    # Tracks the previous point to calculate the distance
    prev_x, prev_y = x0, y0 

    for y in range(y0,y1,-1):
        # Calculate x for the given y
        x = (y - c) / m
        print("cur")
        print(x,y)
        print("prev")
        print(prev_x,prev_y)
        distances.append(calculate_distance(prev_x, prev_y, x, y))
        prev_x = x
        prev_y = y
        grids.append(get_grid_identifier(math.ceil(x),y,grid_point_rows,grid_point_cols))
    return grids , distances

def main():
    # Generate grid with 0.08 degree step
    grid = generate_grid_points(9.6, 9.1 , 78.8, 79.4, 0.08)
    # for row in grid:
    #     for pos in row:
    #         print(pos)

    start_time = time.time()
    
    # # Print the points
    # print("Points the line passes through:")
    # for g in grid:
    #     print(g)

    # calculate_orientation(grid,[(9.6, 78.8),(9.1, 80.2)],0.08)

    print(helper_line_low(0,0,17,2,18,3))

    #ship speed calculation
    #def __init__(self, ship_speed, wave_height, displacement, k1, k2, k3, k4, wind_speed, angle):
    # ship = shipSpeed( 30, 1.26, 200000,  1.08, 0.126, 2.77, 2.33, 15, 30)
    # speed = ship.getSpeed()
    # print(speed)
        
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"Time taken to execute: {elapsed_time:.8f} seconds")


if __name__ == "__main__":
    main()

