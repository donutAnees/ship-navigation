from shipSpeed import shipSpeed
import math
import matplotlib.pyplot as plt
import time
import numpy as np


def generate_grid_points(start_lat, end_lat, start_lon, end_lon, step_deg):
    """
   Generates points which are geographical coordinates (latitude and longitude), 
   based on the specified start and end points with a given step size in degrees. 
   For example, if the step size is 0.08 degrees, then the grid will have a size 
   of 0.08 degrees. 4 adjancent points make one grid.

   8,10--8,11--8,12
    |   1  |  2   |
    |      |      |
   9,10--9,11--9,12

   Here the points are what is generated by this function

    Parameters:
        start_lat: The starting latitude.
        end_lat: The ending latitude.
        start_lon: The starting longitude.
        end_lon: The ending longitude.
        step_deg: The step size in degrees for latitude and longitude.
    Returns:
        list: A 2D list (grid) containing tuples of (latitude, longitude).
    """
    grid = []

    # Adjust step direction based on start and end latitudes
    if start_lat > end_lat:
        lat_step = -step_deg
    else:
        lat_step = step_deg

    # Adjust step direction based on start and end longitudes
    if start_lon > end_lon:
        lon_step = -step_deg
    else:
        lon_step = step_deg

    # Iterate over latitude from start to end with given step
    lat = start_lat
    while (lat_step > 0 and lat <= end_lat) or (lat_step < 0 and lat >= end_lat):
        row = []
        lon = start_lon
        while (lon_step > 0 and lon <= end_lon) or (lon_step < 0 and lon >= end_lon):
            row.append((round(lat, 2), round(lon, 2)))
            lon += lon_step
        grid.append(row)
        lat += lat_step

    return grid

def calculate_orientation(grid, path, step_size):
    '''
    Calculates the orientation of the ship with respect to north in each grid, that is the bearing angle.
    Representation of the 4 direction in degree
        0 degrees: North
        90 degrees: East
        180 degrees: South
        270 degrees: West
    Returns:
        A grid which contains the orientation of the ship, if the ship doesn't travel through that grid, then it is represented as -1
    Parameter:
        grid -> The input grid containing latitude and longitude points.
        path -> The path of the ship as a list of (latitude, longitude). 
        step_deg -> The step size in degrees for latitude and longitude.
    '''
    orientations_grid = [[-1 for _ in range(len(grid[0]))] for _ in range(len(grid))]
    for i in range(len(path) - 1):
        lat1, lon1 = path[i]
        lat2, lon2 = path[i+1]

        # https://en.wikipedia.org/wiki/Atan2 can be used to find the angle measure (in radians, between the positive x-axis 
        # and the ray from the origin to the point (x,y). https://www.movable-type.co.uk/scripts/latlong.html formula taken 
        # from here

        y = math.sin(lon1 - lon2) * math.cos(lat2)
        x = math.cos(lat1) * math.sin(lat2) - math.sin(lat1) * math.cos(lat2) * math.cos(lon1 - lon2)
        thetha = math.atan2(y, x) # In radian
        brng = (thetha * 180 / math.pi + 360) % 360 # In degree

        # Find all the grids which intercept the path between start and end lat lon
        grids = get_intercepting_grid(lat1,lon1,lat2,lon2,grid[0][0][0],grid[0][0][1],step_size)
        for g in grids:
            print(g)  


def get_intercepting_grid(lat1,lon1,lat2,lon2,start_lat1,start_lon1,step):
    '''
    Finds all the grids which touches the path of the ship
    Returns:
        A list of indexes (row, column) in the grid where the ship's path intersects.
    Parameters:
        lat1: The starting latitude of the path.
        lat2: The ending latitude of the path.
        lon1: The starting longitude of the path.
        lon2: The ending longitude of the path.
        start_lat1: The starting latitude of the grid.
        start_lon2: The starting longitude of the grid.
        step: The size of each grid.
    '''

    x0 = int((lon1 - start_lon1) / step)
    y0 = int((start_lat1 - lat1) / step)
    x1 = int((lon2 - start_lon1) / step)
    y1 = int((start_lat1 - lat2) / step)

    if abs(y1 - y0) < abs(x1 - x0):
        if x0 > x1:
            # Slanting from right to left
            grids = helper_line_low(x1, y1, x0, y0)
        else:
            # Slanting from left to right
            grids = helper_line_low(x0, y0, x1, y1)
    else:
        if y0 > y1:
            # Slanting from right to left
            grids = helper_line_high(x1, y1, x0, y0)
        else:
            # Slanting from left to right
            grids = helper_line_high(x0, y0, x1, y1)

    return grids

def helper_line_low(x0, y0, x1, y1):
    grids = []
    # Calculate the slope (m)
    m = (y1 - y0) / (x1 - x0)
    
    # Calculate the y-intercept (c)
    c = y0 - m * x0

    for x in range(x0,x1+1):
        # Calculate y for the given x
        y = m * x + c
        grids.append((x,y))

    return grids

def helper_line_high(x0, y0, x1, y1):
    grids = []
    # Calculate the slope (m)
    m = (y1 - y0) / (x1 - x0)
    
    # Calculate the y-intercept (c)
    c = y0 - m * x0

    for y in range(y0,y1-1,-1):
        # Calculate x for the given y
        x = (y - c) / m
        grids.append((x,y))

    return grids

def main():
    # Generate grid with 0.08 degree step
    grid = generate_grid_points(9.6, 9.1 , 78.8, 80.2, 0.08)
    # for row in grid:
    #     for pos in row:
    #         print(pos)

    start_time = time.time()
    
    # # Print the points
    # print("Points the line passes through:")
    # for g in grid:
    #     print(g)

    calculate_orientation(grid,[(9.6, 78.8),(9.1, 80.2)],0.08)

    #ship speed calculation
    #def __init__(self, ship_speed, wave_height, displacement, k1, k2, k3, k4, wind_speed, angle):
    # ship = shipSpeed( 30, 1.26, 200000,  1.08, 0.126, 2.77, 2.33, 15, 30)
    # speed = ship.getSpeed()
    # print(speed)
        
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"Time taken to execute: {elapsed_time:.8f} seconds")


if __name__ == "__main__":
    main()

